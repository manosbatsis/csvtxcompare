package com.github.manosbatsis.csvtxcompare.missmatches.service;

import java.util.ArrayList;
import java.util.List;

import com.github.manosbatsis.csvtxcompare.missmatches.model.ClientMarkoffFile;
import com.github.manosbatsis.csvtxcompare.missmatches.model.MarkoffFile;
import com.github.manosbatsis.csvtxcompare.missmatches.model.MarkoffFilesComparison;
import com.github.manosbatsis.csvtxcompare.missmatches.model.MarkoffRecord;
import com.github.manosbatsis.csvtxcompare.missmatches.model.TutukaMarkoffFile;
import com.github.manosbatsis.csvtxcompare.missmatches.repository.ClientMarkoffFileRepository;
import com.github.manosbatsis.csvtxcompare.missmatches.repository.MarkoffFilesComparisonRepository;
import com.github.manosbatsis.csvtxcompare.missmatches.repository.MismatchedRecordRepository;
import com.github.manosbatsis.csvtxcompare.missmatches.repository.TutukaMarkoffFileRepository;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.ListUtils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Typical repository interface for {@link MarkoffFilesComparison} entities.
 * Implementation is automatically generated by Spring
 * Created by manos on 12/9/2017.
 */
@Slf4j
@Service()
@Transactional(readOnly = true, rollbackFor = Exception.class)
public class MarkoffFilesComparisonService {

	@Autowired
	private MarkoffFilesComparisonRepository repository;

	@Autowired
	private ClientMarkoffFileRepository clientMarkoffFileRepository;

	@Autowired
	private TutukaMarkoffFileRepository tutukaMarkoffFileRepository;

	@Autowired
	private MismatchedRecordRepository mismatchedRecordRepository;


	/**
	 * Create and persist a markoff files comparison using the given files.
	 * The persistence logic seems a bit verbose but we prefer this
	 * approach VS using cascades with JPA.
	 *
	 * @param clientMarkoff
	 * @param tutukaMarkoff
	 * @return
	 */
	@Transactional(readOnly = false)
	public MarkoffFilesComparison save(ClientMarkoffFile clientMarkoff, TutukaMarkoffFile tutukaMarkoff) {

		// Add the main comparison entity to the transaction
		MarkoffFilesComparison markoffFilesComparison = this.repository.save(new MarkoffFilesComparison());

		// note the original markoff records as they are transient
		// and will be discarded
		List<MarkoffRecord> clientRecords = clientMarkoff.getRecords();
		List<MarkoffRecord> tutukaRecords = tutukaMarkoff.getRecords();
		log.debug("saved clientRecords: {}", clientRecords);
		log.debug("saved tutukaRecords: {}", tutukaRecords);

		// Add the client markoff file to the transaction
		clientMarkoff.setMarkoffFilesComparison(markoffFilesComparison);
		clientMarkoff = this.clientMarkoffFileRepository.save(clientMarkoff);
		markoffFilesComparison.setClientMarkoff(clientMarkoff);

		// Add the tutuka markoff file to the transaction
		tutukaMarkoff.setMarkoffFilesComparison(markoffFilesComparison);
		tutukaMarkoff = this.tutukaMarkoffFileRepository.save(tutukaMarkoff);
		markoffFilesComparison.setTutukaMarkoff(tutukaMarkoff);

		// Create the list of mismatched records per markoff by excluding
		// the intersection of the original record lists.
		// Note: contrary to List.removeAll, the lines bellow respect cardinality
		// TODO: doing this manually VS two irrelevant ListUtils calls can improve performance somewhat
		log.debug("saved clientRecords1: {}", clientRecords);
		log.debug("saved tutukaRecords1: {}", tutukaRecords);
		List<MarkoffRecord> clientMismatchMaps = ListUtils.subtract(clientRecords, tutukaRecords);
		List<MarkoffRecord> tutukaMismatchMaps = ListUtils.subtract(tutukaRecords, clientRecords);
		log.debug("saved clientMismatchMaps: {}", clientMismatchMaps);
		log.debug("saved tutukaMismatchMaps: {}", tutukaMismatchMaps);

		// convert to and set mismatch records per markoff
		this.saveMismatchedRecords(clientMismatchMaps, clientMarkoff);
		this.saveMismatchedRecords(tutukaMismatchMaps, tutukaMarkoff);

		log.debug("saved clientMarkoff: {}", clientMarkoff);
		log.debug("saved tutukaMarkoff: {}", tutukaMarkoff);

		// return the persisted comparison
		return markoffFilesComparison;
	}

	/**
	 * Persist the given mismatched records
	 * @param mismatchedRecords given as a lisat of maps
	 * @param markoffFile the markoff file the maps belong to
	 */
	@Transactional(readOnly = false)
	public void saveMismatchedRecords(List<MarkoffRecord> mismatchedRecords, MarkoffFile markoffFile) {
		log.debug("saveMismatchedRecords, clientMismatchRecords: {}", mismatchedRecords);
		List<MarkoffRecord> saved = new ArrayList<>(mismatchedRecords.size());
		for (MarkoffRecord record : mismatchedRecords) {
			log.debug("saveMismatchedRecords, record: {}", record);
			saved.add(this.mismatchedRecordRepository.save(record));
		}
		markoffFile.setMismatches(saved);
	}

}
